"""Implements the Lin-Kernighan-Helsgaun (LKH) solver
The solver used here is the LKH-3 version [1], which is able to solve CVRP
instances.

References
----------
    [1] https://github.com/cerebis/LKH3
"""
import logging
import os
import subprocess
from dataclasses import dataclass
from typing import Optional

import numpy as np

from loggibud.v1.types import (
    CVRPInstance, CVRPSolution, CVRPSolutionVehicle, JSONDataclassMixin
)
from loggibud.v1.data_conversion import to_tsplib


logger = logging.getLogger(__name__)


@dataclass
class LKHParams(JSONDataclassMixin):
    input_vrp_file: str = "vrp_input_temp.vrp"
    input_par_file: str = "vrp_input_temp.par"
    output_tour_file: str = "vrp_output_temp.vrp"
    time_limit_s: int = 60
    num_runs: int = 1


def solve(
    instance: CVRPInstance, params: Optional[LKHParams] = None
) -> CVRPSolution:
    """Solve a CVRP instance using LKH-3"""

    params = params or LKHParams()

    logger.info("Converting instance into a TSPLIB file")
    convert_instance_file(instance, params)

    logger.info("Calling LKH external solver")
    solve_lkh(instance, params)

    logger.info("Reading result from output files")
    solution = read_solution(instance, params)

    logger.info("Cleaning up temporary files")
    os.remove(params.input_vrp_file)
    os.remove(params.input_par_file)
    os.remove(params.output_tour_file)

    return solution


def convert_instance_file(instance: CVRPInstance, params: LKHParams) -> None:
    """
    The LKH-3 solver requires two files:
        - A .par file with parameters for the solver;
        - A .vrp file with information about the instance.
    The vrp file is created with the original TSPLIB format, and the .par one,
    which is specific for the LKH-3 solver, is created here.
    """

    to_tsplib(instance, file_name=params.input_vrp_file)

    # For the Asymetric CVRP, it only respects the capacity if the number of
    # vehicles is explicitly provided. Here, we use the same rule as the one
    # automatically adopted in the symmetric case
    total_demand = sum(delivery.size for delivery in instance.deliveries)
    num_vehicles = int(np.ceil(total_demand / instance.vehicle_capacity))
    with open(params.input_par_file, "w") as f:
        f.write(
            "SPECIAL\n"
            f"PROBLEM_FILE = {params.input_vrp_file}\n"
            "MTSP_OBJECTIVE = MINSUM\n"
            f"RUNS = {params.num_runs}\n"
            f"TOUR_FILE = {params.output_tour_file}\n"
            f"TIME_LIMIT = {params.time_limit_s}\n"
            f"VEHICLES = {num_vehicles}"
        )


def solve_lkh(instance: CVRPInstance, params: LKHParams) -> None:
    """Call the C solver and generate output files"""

    arguments = ("./loggibud/v1/baselines/task1/LKH", params.input_par_file)
    popen = subprocess.Popen(arguments, stdout=subprocess.PIPE)
    popen.wait()  # run the solver in the background and generate output files


def read_solution(instance: CVRPInstance, params: LKHParams) -> CVRPSolution:
    """Read the files generated by the solver
    The output is somewhat weird: It generates an output file with all routes
    in a TSPLIB format. It has indices of the deliveries in order for each
    route.

    If an index is larger than the total number of locations (origin plus
    deliveries), it marks the end of a route.
    """

    # Read tour file: ignore all header lines and start counting when we hit
    # the `TOUR_SECTION`
    num_locations = len(instance.deliveries) + 1
    with open(params.output_tour_file, "r") as f:
        for line in f:
            if line.startswith("TOUR_SECTION"):
                break

        f.readline()  # ignore next line since it is the depot

        # Fill the routes. Each time a large index comes, it marks the end of a
        # route. If a -1 comes, it is the end of the file
        routes = []
        route = []
        for line in f:
            index = int(line.rstrip("\n"))
            if index == -1:
                routes.append(
                    CVRPSolutionVehicle(
                        origin=instance.origin, deliveries=route
                    )
                )
                break

            # End of a route
            if index > num_locations:
                routes.append(
                    CVRPSolutionVehicle(
                        origin=instance.origin, deliveries=route
                    )
                )
                route = []
                continue

            # Add delivery in route. Notice that the index starts at 2 in the
            # file
            route.append(instance.deliveries[index - 2])

    return CVRPSolution(name=instance.name, vehicles=routes)
